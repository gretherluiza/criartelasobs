<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GERADOR DE TELAS OBS</title>
    <!-- Inclui Tailwind CSS para estilização rápida e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inclui as novas fontes Poppins e Lato do Google Fonts para um design moderno -->
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Poppins:wght@700&family=Oswald:wght@700&display=swap" rel="stylesheet">
    <!-- Inclui JSZip para criar arquivos ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Inclui FileSaver.js para facilitar o download de arquivos -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        /* Estilos CSS para variáveis de tema e tipografia */
        /* Variáveis para o tema escuro moderno */
        :root {
            --bg-color: #1d1934; /* Fundo roxo escuro para o tema escuro */
            --main-container-bg: #1e293b; /* Slate 800 */
            --text-color: #f8fafc; /* Slate 50 */
            --input-bg: #334155; /* Slate 700 */
            --input-text-color: #cbd5e1; /* Slate 300 */
            --generated-area-bg: #1e293b; /* Slate 800 */
            --button-bg: #7d5aff; /* Roxo vibrante */
            --button-hover-bg: #6a46e1; /* Roxo mais escuro para hover */
            --button-focus-ring: #7d5aff; /* Roxo vibrante */
            --border-color: #334155; /* Slate 700 */
        }
        
        /* Tema claro moderno (pode ser ativado pelo seletor de tema) */
        .light-theme {
            --bg-color: #e2e8f0; /* Fundo cinza bem claro para o tema claro */
            --main-container-bg: #ffffff;
            --text-color: #1e293b; /* Slate 800 */
            --input-bg: #f8fafc; /* Slate 50 */
            --input-text-color: #475569; /* Slate 600 */
            --generated-area-bg: #f8fafc; /* Slate 50 */
            --button-bg: #9b59b6; /* Outro tom de roxo */
            --button-hover-bg: #8e44ad; /* Outro tom de roxo para hover */
            --button-focus-ring: #9b59b6; /* Outro tom de roxo */
            --border-color: #e2e8f0; /* Slate 200 */
        }

        /* Estilos para o body usando as variáveis de tema */
        body {
            font-family: 'Lato', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        /* Novo estilo para o título */
        .page-title {
            font-family: 'Oswald', 'Poppins', sans-serif;
            font-weight: 700;
            text-align: center;
            width: auto;
            margin: 0;
            margin-top: 2rem;
            margin-bottom: 5rem;
            line-height: 1.1;
            text-transform: uppercase;
        }

        /* Ajustei os valores do clamp para um título um pouco menor */
        .title-line-1 {
            font-size: clamp(1.5rem, 4vw, 3rem);
            color: var(--text-color);
        }

        /* Cor do título alterada para o valor especificado, agora usando a variável do botão para o tema escuro */
        .title-line-2 {
            font-size: clamp(2rem, 6vw, 4.5rem);
            color: var(--button-bg);
            letter-spacing: -2px;
        }

        /* Estilos para o contêiner principal */
        .main-container {
            background-color: var(--main-container-bg);
            border: 1px solid var(--border-color);
            padding: 2.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            width: 100%;
            transition: background-color 0.3s, box-shadow 0.3s, border-color 0.3s;
        }

        /* Estilos para os campos de texto dinâmicos */
        .text-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 0.5rem;
        }
        .text-input-group textarea {
            flex-grow: 1;
            background-color: var(--input-bg);
            color: var(--input-text-color);
            border-color: var(--border-color);
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Estilos para a área de imagens geradas */
        .generated-images-container {
            display: grid;
            gap: 2rem;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            padding: 1.5rem;
            background-color: var(--generated-area-bg);
            border-radius: 1.5rem;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s, border-color 0.3s;
        }
        .generated-image-item {
            background-color: var(--main-container-bg);
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        .generated-image-item canvas {
            max-width: 100%;
            height: auto;
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
        }
        .generated-image-item a {
            margin-top: 1rem;
            background-color: var(--button-bg);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            text-decoration: none;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .generated-image-item a:hover {
            background-color: var(--button-hover-bg);
            transform: scale(1.05);
        }

        /* Estilos para o spinner de carregamento */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: var(--button-bg);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="flex flex-col items-center min-h-screen p-4">

    <!-- Seletor de Tema (Theme Switcher) movido para o canto superior direito -->
    <div id="themeSwitcher" class="fixed top-4 right-4 z-10 flex space-x-2">
        <button id="light-theme-btn" class="bg-gray-100 text-gray-800 p-2 rounded-lg shadow-md transition-all duration-300 hover:bg-gray-200">Claro</button>
        <button id="dark-theme-btn" class="bg-gray-800 text-white p-2 rounded-lg shadow-md transition-all duration-300 hover:bg-gray-700">Escuro</button>
        <button id="system-theme-btn" class="bg-gray-500 text-white p-2 rounded-lg shadow-md transition-all duration-300 hover:bg-gray-600">Sistema</button>
    </div>
    
    <!-- Contêiner principal para centralizar e limitar a largura do conteúdo -->
    <div class="flex flex-col items-center w-full max-w-5xl mx-auto">
        <!-- Novo título com duas linhas e destaque de cor -->
        <h1 class="page-title">
            <span class="title-line-1 block">GERADOR DE</span>
            <span class="title-line-2 block">TELAS OBS</span>
        </h1>
        
        <div class="main-container mb-16">
            <!-- Container para campos de texto dinâmicos -->
            <div id="textInputsContainer" class="mb-6">
                <!-- As caixas de texto serão adicionadas dinamicamente via JavaScript -->
            </div>

            <div class="flex justify-center mb-6 gap-4">
                <button id="resetButton"
                        class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 focus:ring-offset-[var(--main-container-bg)] transition duration-300 ease-in-out transform hover:scale-105 w-full md:w-auto">
                    Limpar Tudo
                </button>
                <button id="downloadAllZipButton"
                        class="bg-[var(--button-bg)] hover:bg-[var(--button-hover-bg)] text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:ring-2 focus:ring-[var(--button-focus-ring)] focus:ring-offset-2 focus:ring-offset-[var(--main-container-bg)] transition duration-300 ease-in-out transform hover:scale-105 w-full md:w-auto">
                    Baixar Todas as Imagens (ZIP)
                </button>
            </div>
        </div>
    </div>
    
    <!-- Área de Exibição das Imagens Geradas -->
    <div id="generatedImagesDisplay" class="generated-images-container w-full max-w-5xl mx-auto">
        <p class="text-slate-400 text-center col-span-full" id="noImagesMessage">Nenhuma imagem gerada ainda.</p>
        <!-- Imagens geradas serão inseridas aqui -->
    </div>

    <script>
        const textInputsContainer = document.getElementById('textInputsContainer');
        const downloadAllZipButton = document.getElementById('downloadAllZipButton');
        const resetButton = document.getElementById('resetButton'); // Novo botão
        const generatedImagesDisplay = document.getElementById('generatedImagesDisplay');
        const noImagesMessage = document.getElementById('noImagesMessage');
        const lightThemeBtn = document.getElementById('light-theme-btn');
        const darkThemeBtn = document.getElementById('dark-theme-btn');
        const systemThemeBtn = document.getElementById('system-theme-btn');

        const predefinedImageUrl = "https://i.imgur.com/je8XhfE.png";
        const numberOfTextFields = 9; // Limite total de caixas de texto

        let generatedCanvases = [];
        let preloadedImage = null; // Variável para a imagem pré-carregada

        /**
         * Função para "deixar de lado" as ações por um curto período de tempo.
         * Isso evita que a função de geração de imagem seja chamada a cada tecla digitada.
         * @param {Function} func - A função a ser executada.
         * @param {number} timeout - O tempo de espera em milissegundos.
         */
        const debounce = (func, timeout = 300) => {
            let timer;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => { func.apply(this, args); }, timeout);
            };
        };

        // Cria uma versão "debounced" da função de geração de imagem
        const debouncedGenerateImage = debounce((textarea, index) => {
            generateImageForInput(textarea, index);
        });

        /**
         * Adiciona um novo campo de texto dinamicamente ao contêiner.
         * @param {number} index - O índice do campo de texto (começando em 1).
         */
        function addTextField(index) {
            // Se o número de campos já atingiu o limite, não adiciona mais.
            if (index > numberOfTextFields) {
                return;
            }

            const newGroupId = `text-input-group-${index}`;
            const newTextareaId = `overlayText-${index}`;
            
            const newGroup = document.createElement('div');
            newGroup.className = 'text-input-group';
            newGroup.id = newGroupId;
            newGroup.innerHTML = `
                <label for="${newTextareaId}" class="sr-only">Texto a sobrepor ${index}:</label>
                <textarea id="${newTextareaId}" rows="2" placeholder="Digite o nome do tema ${index}..."
                          class="bg-[var(--input-bg)] text-[var(--input-text-color)] border border-[var(--border-color)] rounded-xl w-full py-2 px-3 leading-tight focus:outline-none focus:ring-2 focus:ring-[var(--button-focus-ring)] focus:ring-opacity-50 resize-y transition-colors duration-300"></textarea>
            `;
            textInputsContainer.appendChild(newGroup);

            const textarea = newGroup.querySelector('textarea');
            
            // Adiciona o listener para a geração de imagem debounced
            textarea.addEventListener('input', () => {
                debouncedGenerateImage(textarea, index);
            });

            // Adiciona um listener separado para a adição de novas caixas, sem debounce
            textarea.addEventListener('input', () => {
                const text = textarea.value.trim();
                const allTextareas = textInputsContainer.querySelectorAll('textarea');
                // Se a caixa atual for a última e tiver conteúdo, adiciona a próxima
                if (text !== '' && index === allTextareas.length) {
                    addTextField(index + 1);
                }
            });
        }

        /**
         * Ajusta o tamanho da fonte e quebra o texto para caber na área de desenho.
         * @param {CanvasRenderingContext2D} ctx - O contexto do canvas.
         * @param {string} text - O texto a ser ajustado.
         * @param {number} boxWidth - Largura da caixa de texto.
         * @param {number} boxHeight - Altura da caixa de texto.
         * @param {number} initialFontSizePt - Tamanho da fonte inicial em 'pt'.
         * @returns {{fontSize: number, lines: string[]}} - O tamanho da fonte final e as linhas de texto.
         */
        function adjustFontSizeForCanvas(ctx, text, boxWidth, boxHeight, initialFontSizePt) {
            let fontSize = initialFontSizePt;
            let lines = [];
            const minAllowedFontSizePt = 8;

            const wrapText = (context, textToWrap, maxWidth) => {
                const words = textToWrap.split(' ');
                let line = '';
                let testLine = '';
                let lineArray = [];

                for (let n = 0; n < words.length; n++) {
                    testLine = line + words[n] + ' ';
                    const metrics = context.measureText(testLine);
                    const testWidth = metrics.width;

                    if (testWidth > maxWidth && n > 0) {
                        lineArray.push(line.trim());
                        line = words[n] + ' ';
                    } else {
                        line = testLine;
                    }
                }
                lineArray.push(line.trim());
                return lineArray;
            };

            while (fontSize >= minAllowedFontSizePt) {
                ctx.font = `bold ${fontSize}pt Oswald`;
                lines = wrapText(ctx, text, boxWidth);

                const textMetrics = ctx.measureText("M");
                const lineHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 76;
                const totalTextHeight = lines.length * lineHeight;

                if (totalTextHeight <= boxHeight) {
                    break;
                }
                fontSize -= 0.5;
            }
            if (fontSize < minAllowedFontSizePt) {
                console.warn(`[adjustFontSizeForCanvas] Fonte atingiu o tamanho mínimo de ${minAllowedFontSizePt}pt e o texto ainda pode não caber.`);
            }
            return { fontSize: fontSize, lines: lines };
        }

        /**
         * Gera a imagem com texto no canvas usando a imagem pré-carregada.
         * @param {string} text - O texto a ser sobreposto.
         * @returns {HTMLCanvasElement|null} - O canvas gerado ou null em caso de erro.
         */
        function generateImageWithText(text) {
            if (!preloadedImage) {
                console.error("[generateImageWithText] A imagem base ainda não foi carregada.");
                return null;
            }

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = preloadedImage.naturalWidth;
            canvas.height = preloadedImage.naturalHeight;

            ctx.drawImage(preloadedImage, 0, 0);

            const boxWidth = 0.9547 * canvas.width;
            const boxHeight = 0.13998 * canvas.height;
            const boxTop = 0.023148 * canvas.height;
            const boxLeft = 0.0229 * canvas.width;

            ctx.fillStyle = 'white';

            const processedText = text.toUpperCase();
            const { fontSize, lines } = adjustFontSizeForCanvas(ctx, processedText, boxWidth, boxHeight, 180);

            ctx.font = `bold ${fontSize}pt Oswald`;

            const textMetrics = ctx.measureText("M");
            const lineHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 76;
            const totalTextHeight = lines.length * lineHeight;
            let startY = boxTop + (boxHeight - totalTextHeight) / 2 + textMetrics.actualBoundingBoxAscent;

            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], boxLeft, startY + (i * lineHeight));
            }

            return canvas;
        }
        
        /**
         * Gera a imagem para um campo de input específico e atualiza a exibição.
         * @param {HTMLTextAreaElement} textarea - O elemento de textarea que disparou o evento.
         * @param {number} index - O índice do campo de texto.
         */
        async function generateImageForInput(textarea, index) {
            const text = textarea.value.trim();
            const themeNumber = String(index).padStart(2, '0');
            const placeholderId = `image-placeholder-${themeNumber}`;
            
            let imagePlaceholder = document.getElementById(placeholderId);

            if (!imagePlaceholder) {
                imagePlaceholder = document.createElement('div');
                imagePlaceholder.id = placeholderId;
                imagePlaceholder.className = 'generated-image-item';
                generatedImagesDisplay.appendChild(imagePlaceholder);
            }

            // Se o texto estiver vazio, remove apenas a imagem e o canvas do array
            if (text === '') {
                // Remove a imagem do array de canvases para o ZIP
                generatedCanvases = generatedCanvases.filter(item => item.name !== `Tema ${themeNumber}.png`);
                imagePlaceholder.innerHTML = ''; // Limpa o conteúdo do placeholder
                imagePlaceholder.style.display = 'none'; // Esconde o placeholder

                // Se não houver mais imagens visíveis, mostra a mensagem de placeholder
                const visibleImages = generatedImagesDisplay.querySelectorAll('.generated-image-item:not([style*="display: none"])');
                if (visibleImages.length === 0) {
                    noImagesMessage.classList.remove('hidden');
                }
                return;
            }
            
            noImagesMessage.classList.add('hidden');
            imagePlaceholder.style.display = 'flex'; // Garante que o placeholder esteja visível
            // Exibe um spinner enquanto a imagem é gerada
            imagePlaceholder.innerHTML = '<div class="spinner mx-auto my-8"></div>';
            
            const canvas = generateImageWithText(text);

            if (canvas) {
                // Adiciona ou atualiza o canvas no array para o download ZIP
                const existingIndex = generatedCanvases.findIndex(item => item.name === `Tema ${themeNumber}.png`);
                if (existingIndex !== -1) {
                    generatedCanvases[existingIndex] = { canvas: canvas, name: `Tema ${themeNumber}.png` };
                } else {
                    generatedCanvases.push({ canvas: canvas, name: `Tema ${themeNumber}.png` });
                }

                const imageDataUrl = canvas.toDataURL('image/png');
                const imgElement = document.createElement('img');
                imgElement.src = imageDataUrl;
                imgElement.alt = `Imagem Gerada ${index}`;
                imgElement.style.maxWidth = '100%';
                imgElement.style.height = 'auto';

                const downloadLink = document.createElement('a');
                downloadLink.href = imageDataUrl;
                downloadLink.download = `Tema ${themeNumber}.png`;
                downloadLink.textContent = 'Baixar Imagem Individual';
                downloadLink.className = "bg-[var(--button-bg)] hover:bg-[var(--button-hover-bg)] text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:ring-2 focus:ring-[var(--button-focus-ring)] focus:ring-offset-2 focus:ring-offset-[var(--main-container-bg)] transition duration-300 ease-in-out transform hover:scale-105 w-full text-center mt-4";


                imagePlaceholder.innerHTML = '';
                imagePlaceholder.appendChild(imgElement);
                imagePlaceholder.appendChild(downloadLink);
                
            } else {
                imagePlaceholder.remove();
            }
        }
        
        downloadAllZipButton.addEventListener('click', async () => {
            if (generatedCanvases.length === 0) {
                // Use uma modal personalizada em vez de alert()
                showCustomAlert('Por favor, gere as imagens primeiro antes de tentar baixar o ZIP.');
                return;
            }

            const zip = new JSZip();
            const zipFileName = `telas_obs_${Date.now()}.zip`;

            const originalButtonText = downloadAllZipButton.textContent;
            downloadAllZipButton.textContent = 'Gerando ZIP...';
            downloadAllZipButton.disabled = true;

            try {
                for (const item of generatedCanvases) {
                    const blob = await new Promise(resolve => item.canvas.toBlob(resolve, 'image/png'));
                    const arrayBuffer = await blob.arrayBuffer();
                    zip.file(item.name, arrayBuffer);
                }

                const content = await zip.generateAsync({ type: "blob" });
                saveAs(content, zipFileName);
            } catch (error) {
                console.error("Erro ao gerar o arquivo ZIP:", error);
                // Use uma modal personalizada em vez de alert()
                showCustomAlert('Ocorreu um erro ao gerar o arquivo ZIP. Por favor, tente novamente.');
            } finally {
                downloadAllZipButton.textContent = originalButtonText;
                downloadAllZipButton.disabled = false;
            }
        });
        
        // --- Lógica do Botão de Limpar Tudo ---
        resetButton.addEventListener('click', () => {
            // Limpa o contêiner de inputs de texto
            textInputsContainer.innerHTML = '';
            // Limpa o contêiner de imagens geradas
            generatedImagesDisplay.innerHTML = '';
            // Mostra a mensagem de "Nenhuma imagem" novamente
            noImagesMessage.classList.remove('hidden');
            // Limpa o array de canvases gerados
            generatedCanvases = [];
            // Recomeça o processo adicionando o primeiro campo de texto
            addTextField(1);
        });

        // --- Lógica do Seletor de Tema ---
        /**
         * Aplica o tema selecionado à página e salva a preferência no localStorage.
         * @param {string} theme - O nome do tema ('light', 'dark', 'system').
         */
        function applyTheme(theme) {
            const root = document.documentElement;
            localStorage.setItem('theme', theme);
            
            // Remove as classes de tema existentes para evitar conflitos
            root.classList.remove('light-theme', 'dark-theme');
            
            // Aplica a classe do tema selecionado
            if (theme === 'dark') {
                root.classList.add('dark-theme');
            } else if (theme === 'light') {
                root.classList.add('light-theme');
            }
            // Para o tema 'system', nenhuma classe específica é adicionada.
            // O CSS com `@media (prefers-color-scheme: dark)` cuidará da aplicação do tema correto.
        }

        // Adiciona listeners para os botões do seletor de tema
        lightThemeBtn.addEventListener('click', () => applyTheme('light'));
        darkThemeBtn.addEventListener('click', () => applyTheme('dark'));
        systemThemeBtn.addEventListener('click', () => applyTheme('system'));
        
        // Listener para mudanças no tema do sistema
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'system') {
                applyTheme('system');
            }
        });
        
        // --- Modal Personalizada para Alertas ---
        /**
         * Cria e exibe uma modal de alerta personalizada.
         * @param {string} message - A mensagem a ser exibida na modal.
         */
        function showCustomAlert(message) {
            const modalId = 'custom-alert-modal';
            let modal = document.getElementById(modalId);
            
            if (!modal) {
                // Se a modal não existe, cria ela
                modal = document.createElement('div');
                modal.id = modalId;
                modal.className = 'fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50 transition-opacity duration-300';
                modal.innerHTML = `
                    <div class="bg-[var(--main-container-bg)] rounded-2xl shadow-xl p-6 max-w-sm w-full transform transition-transform duration-300 scale-95 border border-[var(--border-color)]">
                        <div class="text-xl font-bold mb-4 text-[var(--text-color)]">Aviso</div>
                        <p id="custom-alert-message" class="text-[var(--text-color)] mb-6">${message}</p>
                        <div class="flex justify-end">
                            <button id="custom-alert-close-btn" class="bg-[var(--button-bg)] hover:bg-[var(--button-hover-bg)] text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:ring-2 focus:ring-[var(--button-focus-ring)] focus:ring-opacity-50">OK</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                // Adiciona o evento de fechamento
                document.getElementById('custom-alert-close-btn').addEventListener('click', () => {
                    modal.classList.add('opacity-0');
                    setTimeout(() => modal.remove(), 300);
                });
            } else {
                // Se a modal já existe, apenas atualiza a mensagem e mostra
                document.getElementById('custom-alert-message').textContent = message;
                modal.classList.remove('opacity-0');
            }
        }

        // Função de configuração inicial da aplicação
        const setupApp = async () => {
            // Verifica se há um tema salvo no localStorage e o aplica
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(savedTheme);
            } else {
                applyTheme('system'); // Aplica o tema do sistema por padrão se não houver preferência salva
            }

            // Pré-carregamento da imagem base
            preloadedImage = new Image();
            preloadedImage.crossOrigin = "Anonymous";
            preloadedImage.src = predefinedImageUrl;

            // Espera a imagem carregar
            await new Promise(resolve => {
                preloadedImage.onload = () => resolve();
                preloadedImage.onerror = () => {
                    console.error("Erro ao pré-carregar a imagem base.");
                    resolve(); // Resolve mesmo com erro para não travar a aplicação
                };
            });

            // Pré-carregamento da fonte
            try {
                // Otimizado para carregar as fontes de forma assíncrona
                await document.fonts.load('700 240px Oswald');
                await document.fonts.load('700 240px Poppins');
                await document.fonts.load('400 240px Lato');
            } catch (error) {
                console.error("Erro ao pré-carregar as fontes:", error);
            }

            // Inicia a aplicação com o primeiro campo de texto
            addTextField(1);
        };
        
        // Inicia a configuração da aplicação quando o DOM estiver completamente carregado
        document.addEventListener('DOMContentLoaded', setupApp);
    </script>
</body>
</html>
