<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GERADOR DE TELAS OBS</title>
    <!-- Inclui Tailwind CSS para estilização rápida e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inclui a fonte Oswald do Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;700&display=swap" rel="stylesheet">
    <!-- Inclui JSZip para criar arquivos ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Inclui FileSaver.js para facilitar o download de arquivos -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        /* Define a fonte Inter para todo o corpo da página */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilos para o contêiner principal */
        .main-container {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 48rem; /* Equivalente a max-w-2xl no Tailwind */
            margin-bottom: 2rem;
        }
        /* Estilos para os campos de texto dinâmicos */
        .text-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            gap: 0.5rem;
        }
        .text-input-group textarea {
            flex-grow: 1;
        }
        /* Botões de remover foram removidos, então este estilo não é mais estritamente necessário para eles */
        .text-input-group button {
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .text-input-group button:hover {
            transform: scale(1.05);
        }
        /* Estilos para a área de imagens geradas */
        .generated-images-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            padding: 1.5rem;
            background-color: #f9fafb;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }
        .generated-image-item {
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
        }
        .generated-image-item canvas {
            max-width: 100%;
            height: auto;
            border: 1px solid #ccc; /* Borda para o canvas gerado */
            border-radius: 0.375rem;
        }
        .generated-image-item a {
            margin-top: 1rem;
            background-color: #10b981; /* bg-emerald-500 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            text-decoration: none;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .generated-image-item a:hover {
            background-color: #059669; /* bg-emerald-600 */
            transform: scale(1.05);
        }

        /* Estilos para o spinner de carregamento */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6; /* Cor do spinner */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="main-container">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">GERADOR DE TELAS OBS</h1>

        <!-- Container para campos de texto dinâmicos -->
        <div id="textInputsContainer" class="mb-6">
            <!-- Os 9 campos de texto serão gerados via JavaScript -->
        </div>

        <div class="flex justify-center mb-6 gap-4">
            <!-- O botão "Adicionar Campo de Texto" foi removido -->
            <button id="generateAllImagesButton"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition duration-300 ease-in-out transform hover:scale-105">
                Gerar Todas as Imagens
            </button>
            <button id="downloadAllZipButton"
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 transition duration-300 ease-in-out transform hover:scale-105">
                Baixar Todas as Imagens (ZIP)
            </button>
        </div>
    </div>

    <!-- Área de Exibição das Imagens Geradas -->
    <div id="generatedImagesDisplay" class="generated-images-container w-full max-w-2xl">
        <p class="text-gray-600 text-center col-span-full" id="noImagesMessage">Nenhuma imagem gerada ainda.</p>
        <!-- Imagens geradas serão inseridas aqui -->
    </div>

    <script>
        const textInputsContainer = document.getElementById('textInputsContainer');
        const generateAllImagesButton = document.getElementById('generateAllImagesButton');
        const downloadAllZipButton = document.getElementById('downloadAllZipButton'); // Novo botão
        const generatedImagesDisplay = document.getElementById('generatedImagesDisplay');
        const noImagesMessage = document.getElementById('noImagesMessage');

        // URL da imagem base
        const predefinedImageUrl = "https://i.imgur.com/je8XhfE.png";

        // Variável para controlar o número de campos de texto
        const numberOfTextFields = 9;

        // Armazenará os canvases gerados para o download ZIP
        let generatedCanvases = [];

        // Função para adicionar um novo campo de texto (sem botão de remover)
        function addTextField(index) {
            const newGroupId = `text-input-group-${index}`;
            const newTextareaId = `overlayText-${index}`;

            const newGroup = document.createElement('div');
            newGroup.className = 'text-input-group';
            newGroup.id = newGroupId;
            newGroup.innerHTML = `
                <label for="${newTextareaId}" class="sr-only">Texto a sobrepor ${index}:</label>
                <textarea id="${newTextareaId}" rows="2" placeholder="Digite o nome do tema ${index}..."
                          class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-y"></textarea>
            `;
            textInputsContainer.appendChild(newGroup);
        }

        // Função para ajustar o tamanho da fonte para caber na área
        // Usa `initialFontSizePt` como ponto de partida e reduz se necessário
        function adjustFontSizeForCanvas(ctx, text, boxWidth, boxHeight, initialFontSizePt) {
            let fontSize = initialFontSizePt;
            let lines = [];
            const minAllowedFontSizePt = 8; // Um mínimo razoável para evitar que a fonte desapareça

            console.log(`[adjustFontSizeForCanvas] Início do ajuste de fonte. boxWidth: ${boxWidth}, boxHeight: ${boxHeight}, initialFontSizePt: ${initialFontSizePt}`);

            // Função auxiliar para quebrar o texto em linhas
            const wrapText = (context, textToWrap, maxWidth) => {
                const words = textToWrap.split(' ');
                let line = '';
                let testLine = '';
                let lineArray = [];

                for (let n = 0; n < words.length; n++) {
                    testLine = line + words[n] + ' ';
                    const metrics = context.measureText(testLine);
                    const testWidth = metrics.width;

                    if (testWidth > maxWidth && n > 0) {
                        lineArray.push(line.trim());
                        line = words[n] + ' ';
                    } else {
                        line = testLine;
                    }
                }
                lineArray.push(line.trim());
                return lineArray;
            };

            // Loop para reduzir o tamanho da fonte até que caiba ou atinja o mínimo
            while (fontSize >= minAllowedFontSizePt) {
                ctx.font = `bold ${fontSize}pt Oswald`; // Usando 'pt' aqui
                lines = wrapText(ctx, text, boxWidth);

                // Calcula a altura total do texto
                const textMetrics = ctx.measureText("M"); // Usar uma letra para altura aproximada
                const lineHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 76;
                const totalTextHeight = lines.length * lineHeight;

                console.log(`[adjustFontSizeForCanvas] Testando font: bold ${fontSize}pt Oswald. Linhas: ${lines.length}, Altura Total Texto: ${totalTextHeight}, Altura da Caixa: ${boxHeight}`);

                if (totalTextHeight <= boxHeight) {
                    console.log(`[adjustFontSizeForCanvas] Texto cabe. Fonte final: bold ${fontSize}pt Oswald`);
                    break; // O texto cabe
                }
                console.log(`[adjustFontSizeForCanvas] Texto não cabe em ${fontSize}pt. Reduzindo...`);
                fontSize -= 0.5; // Reduz a fonte
            }
            if (fontSize < minAllowedFontSizePt) {
                console.warn(`[adjustFontSizeForCanvas] Fonte atingiu o tamanho mínimo de ${minAllowedFontSizePt}pt e o texto ainda pode não caber.`);
            }
            return { fontSize: fontSize, lines: lines };
        }

        // Função para gerar uma imagem com texto
        async function generateImageWithText(text) {
            return new Promise(async (resolve) => {
                // Esperar a fonte 'Oswald' carregar antes de tentar desenhar
                try {
                    // Carrega a fonte com um peso específico (700 para negrito) e um tamanho para garantir que esteja pronta.
                    // Convertendo 180pt para px para o carregamento inicial (1pt = 4/3px)
                    await document.fonts.load('700 240px Oswald'); // 180pt = 240px
                    console.log("[generateImageWithText] Fonte 'Oswald' carregada com sucesso.");
                } catch (error) {
                    console.error("[generateImageWithText] Erro ao carregar a fonte Oswald:", error);
                    // Continuar mesmo se a fonte não carregar, talvez com uma fonte padrão
                }

                const img = new Image();
                img.crossOrigin = "Anonymous"; // Necessário para carregar imagens de domínios diferentes no canvas
                img.src = predefinedImageUrl;

                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // Draw a dummy text off-screen to ensure font is active
                    // Definindo a fonte Oswald em 180pt (240px) para o texto dummy
                    ctx.font = 'bold 240px Oswald';
                    ctx.fillText('a', -100, -100); // Desenha fora da tela

                    // Definir o tamanho do canvas para o tamanho nativo da imagem
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;

                    // Desenhar a imagem no canvas
                    ctx.drawImage(img, 0, 0);

                    // --- Configurações da caixa de texto e texto (em pixels, baseadas na imagem 1920x1080) ---
                    // Largura da imagem base: 1920px
                    // Altura da imagem base: 1080px

                    // Converter porcentagens para pixels com base nas dimensões da imagem base
                    // 48.5 cm convertido para porcentagem da largura da imagem (1920px) = 95.47%
                    const boxWidth = 0.9547 * canvas.width;
                    // 4 cm convertido para porcentagem da altura da imagem (1080px) = 13.998%
                    const boxHeight = 0.13998 * canvas.height;
                    // 25px do topo, convertido para porcentagem da altura da imagem (1080px) = 2.3148%
                    const boxTop = 0.023148 * canvas.height;
                    // 44px da esquerda, convertido para porcentagem da largura da imagem (1920px) = 2.29%
                    const boxLeft = 0.0229 * canvas.width;

                    ctx.fillStyle = 'white'; // Cor do texto

                    // Converte o texto para maiúsculas antes de passá-lo para a função de ajuste
                    const processedText = text.toUpperCase();

                    // Ajustar e quebrar o texto - passando 180 como initialFontSizePt
                    const { fontSize, lines } = adjustFontSizeForCanvas(ctx, processedText, boxWidth, boxHeight, 180);

                    // Garante que a fonte Oswald seja aplicada com o tamanho calculado
                    ctx.font = `bold ${fontSize}pt Oswald`; // Usando 'pt'
                    console.log(`[generateImageWithText] Fonte aplicada ao canvas: ${ctx.font}`);


                    // Calcular a altura total do texto para centralização vertical
                    const textMetrics = ctx.measureText("M");
                    // Usando o mesmo espaçamento de linha para o cálculo de posicionamento
                    const lineHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 76;
                    const totalTextHeight = lines.length * lineHeight;

                    // Calcular a posição Y inicial para centralizar verticalmente
                    let startY = boxTop + (boxHeight - totalTextHeight) / 2 + textMetrics.actualBoundingBoxAscent;

                    // Desenhar cada linha do texto
                    for (let i = 0; i < lines.length; i++) {
                        ctx.fillText(lines[i], boxLeft, startY + (i * lineHeight));
                    }

                    resolve(canvas); // Retorna o canvas com a imagem e texto
                };

                img.onerror = () => {
                    console.error("[generateImageWithText] Erro ao carregar a imagem base:", predefinedImageUrl);
                    resolve(null); // Resolve com null em caso de erro
                };
            });
        }

        // Event listener para o botão "Gerar Todas as Imagens"
        generateAllImagesButton.addEventListener('click', async () => {
            generatedImagesDisplay.innerHTML = ''; // Limpa a área de exibição
            noImagesMessage.classList.add('hidden'); // Esconde a mensagem "Nenhuma imagem gerada"
            generatedCanvases = []; // Limpa o array de canvases gerados

            const textareas = textInputsContainer.querySelectorAll('textarea');
            if (textareas.length === 0) {
                noImagesMessage.classList.remove('hidden');
                return;
            }

            // Mostra um spinner geral enquanto as imagens são geradas
            const globalSpinner = document.createElement('div');
            globalSpinner.className = 'spinner mx-auto my-8';
            generatedImagesDisplay.appendChild(globalSpinner);

            for (let i = 0; i < textareas.length; i++) {
                const textarea = textareas[i];
                const text = textarea.value.trim();
                if (text) {
                    const canvas = await generateImageWithText(text);
                    if (canvas) {
                        // Formata o número com zero à esquerda se for menor que 10
                        const themeNumber = String(i + 1).padStart(2, '0');
                        generatedCanvases.push({ canvas: canvas, name: `Tema ${themeNumber}.png` }); 
                        const imageDataUrl = canvas.toDataURL('image/png');

                        const imageItem = document.createElement('div');
                        imageItem.className = 'generated-image-item';

                        const imgElement = document.createElement('img');
                        imgElement.src = imageDataUrl;
                        imgElement.alt = `Imagem Gerada ${i + 1}`;
                        imgElement.style.maxWidth = '100%';
                        imgElement.style.height = 'auto';

                        const downloadLink = document.createElement('a');
                        downloadLink.href = imageDataUrl;
                        // Formata o número com zero à esquerda para o download individual
                        downloadLink.download = `Tema ${themeNumber}.png`; 
                        downloadLink.textContent = 'Baixar Imagem Individual';

                        imageItem.appendChild(imgElement);
                        imageItem.appendChild(downloadLink);
                        generatedImagesDisplay.appendChild(imageItem);
                    }
                }
            }
            globalSpinner.remove(); // Remove o spinner após todas as imagens geradas
            if (generatedImagesDisplay.children.length === 0) {
                noImagesMessage.classList.remove('hidden'); // Mostra a mensagem se nenhuma imagem foi gerada
            }
        });

        // Event listener para o novo botão "Baixar Todas as Imagens (ZIP)"
        downloadAllZipButton.addEventListener('click', async () => {
            if (generatedCanvases.length === 0) {
                alert('Por favor, gere as imagens primeiro antes de tentar baixar o ZIP.');
                return;
            }

            const zip = new JSZip();
            const zipFileName = `telas_obs_${Date.now()}.zip`; // Nome do arquivo ZIP

            // Adiciona um spinner ao botão de download ZIP
            const originalButtonText = downloadAllZipButton.textContent;
            downloadAllZipButton.textContent = 'Gerando ZIP...';
            downloadAllZipButton.disabled = true;

            try {
                for (const item of generatedCanvases) {
                    // Converte o canvas para Blob e depois para ArrayBuffer para adicionar ao ZIP
                    const blob = await new Promise(resolve => item.canvas.toBlob(resolve, 'image/png'));
                    const arrayBuffer = await blob.arrayBuffer();
                    zip.file(item.name, arrayBuffer); // Usa o nome "Tema X.png" (já formatado com zero à esquerda)
                }

                const content = await zip.generateAsync({ type: "blob" });
                saveAs(content, zipFileName); // Usa FileSaver.js para baixar o arquivo
            } catch (error) {
                console.error("Erro ao gerar o arquivo ZIP:", error);
                alert('Ocorreu um erro ao gerar o arquivo ZIP. Por favor, tente novamente.');
            } finally {
                downloadAllZipButton.textContent = originalButtonText;
                downloadAllZipButton.disabled = false;
            }
        });

        // Adiciona os 9 campos de texto iniciais ao carregar a página
        window.onload = () => {
            for (let i = 1; i <= numberOfTextFields; i++) {
                addTextField(i);
            }
            noImagesMessage.classList.remove('hidden'); // Garante que a mensagem inicial esteja visível
        };
        // Fim do script JavaScript.
    </script>
</body>
</html>
